<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>github.com/patrickbergden/</title>
   
   <link>http://github.com/patrickbergden/</link>
   <description>Reflektioner kring investering i aktier, råvaror, kryptovalutor och om att njuta av livet i största allmänhet.</description>
   <language>en-uk</language>
   <managingEditor> Patrick Bergden</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Decred<br>&mdash;en ny kryptovaluta</title>
	  <link>//decred</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-03-02T11:59:00+01:00</pubDate>
	  <guid>//decred</guid>
	  <description><![CDATA[
	     <h2>Kommande poster</h2>

<blockquote>
<p>samtliga med Golang code på Github eller Go playground eller YouTube vid:</p>
</blockquote>

<ul>
<li>  Monte Carlo</li>
<li>  Go-SWIFT</li>
<li>  Elliptic Curve crypto</li>
<li>  Deep Learning</li>
<li>  Morad och Volume Profile trading</li>
<li>  NLP i Smart Contracts</li>
<li>  Ny bok - Bitcoin på Svenska</li>
<li>  Ny bok - Ethereum och Smarta Kontrakt</li>
<li>  Ny bok - Blockchain Bank (skinner hat tip)</li>
<li>  Ny bok - Colored Coins (Dorier)</li>
<li>  Ny post - Bitcoin på Låg nivå</li>
<li>  Skapa en egen kryptovaluta</li>
<li>  Central Banks krypto (RSCoin)</li>
<li>  DVP på blockkedjan</li>
<li>  Hur skapar man en exchange</li>
<li>  HTTP Request/response</li>
<li>  Elvine projekt</li>
<li>  Coffee-trindikit</li>
<li>  Go-Bitcoin</li>
<li>  Go-trindikit</li>
<li>  Trading view chat scrollspeed monitor</li>
<li>  NLTK port some functions to Go</li>
<li>  ChangeTip genom Go</li>
</ul>

<h4>Från metod till funktion</h4>

<p>Python exemplet har en metod (en klassfunktion) som heter <strong>printVal</strong>.<br>
Vid anrop returnerar metoden värdet hos den anropade instansens variabel <code>val</code>.</p>

<p>Go har som sagt inte några klasser, därför får vi lösa detta på ett annat sätt.<br>
För att replikerar denna funktionalitet i Go skapar vi <strong>en fristående funktion</strong>
<code>printVal</code> med en <strong>pekare mot structen Foo</strong>.
<pre>
func (f *Foo) printVal() {
}
</pre></p>

<h4>Skriv ut den interna variabeln</h4>

<p>Avslutningsvis så behöver funktionen hämta värdet på variabeln
val i structen Foo och skriva ut den med <code>fmt.Println</code>.
<pre>
func (f *Foo) printVal() {
    fmt.Println(f.val)
}
</pre></p>

<h2>Proof of Work - Proof of Stake Hybrid</h2>

<h2>Schnorr Digitala Signaturer</h2>

	  ]]></description>
	</item>

	<item>
	  <title>Programspråket Go <br>har ingen class</title>
	  <link>//transition-to-go</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-12T11:59:00+01:00</pubDate>
	  <guid>//transition-to-go</guid>
	  <description><![CDATA[
	     <p>Jag har använt objektorienterad programmering i
över 20 år (jag började med Java 1.1, 1996).</p>

<p>Nu vill jag absolut inte kalla mig själv någon
duktig programmerare, men OOP tänket sitter rätt
hårt när jag börjar tänka hur jag skall koda ett projekt.</p>

<p>Python, Java, C++, Ruby och Javascript är några av
det språk som har färgat mitt sätt att tänka i OOP.
Alla har saker jag gillar - och en del saker jag ogillar.</p>

<p>För några år sedan fick jag upp ögonen för Go, Googles
nya språk. Det såg mest ut som C och kändes konstigt nog
ganska &#39;omodernt&#39; i jämförelse med kändisspråken Python
och Ruby.</p>

<p>Efter att ha spenderat en hel del tid med en hyffsat
stor (för mig) Javascript kod, så började jag sakta
tröttna på att skriva i ett dynamiskt språk utan typ kontroll.</p>

<p>Det började kännas olustigt att helt enkelt inte veta,
eller ständigt behöva kontrollera, vad en variabel
var för något.</p>

<p>För ett tag sedan kom jag å tänka på det där hårt typade
språket jag läst om några år tidigare.</p>

<p>Go - kändes plötsligt helt självklart att lära sig.
Litet, hårt typat med en grym compiler, inbyggd concurrency
och ett komplett standardbibliotek.</p>

<h3>What? Har Go inga klasser?</h3>

<p>Två saker blev genast en tröskel när jag började lära mig Go.<br>
1. Go är hårt typat och kompilatorn är stenhård på detta.<br>
2. Go har inga klasser eller inheritance.  </p>

<p>I början kändes nummer 1 ganska tröttsamt, men man vande sig sakta
och numera känns det bara skönt att veta att kompilatorn håller koll.
Nummer 2 däremot lämnade mig med en känsla av:</p>

<blockquote>
<p>&quot;Hur fan skriver man ett program utan klasser?&quot;</p>
</blockquote>

<p>Om du som läser detta undrat samma sak så hoppas jag att du kanske blir
hjälpt av att se ett exempel på hur man kan &#39;överstätta&#39; en Python klass
till samma funktionalitet i Go (alltså utan klasser).</p>

<h3>Klasser i Python</h3>

<p>Här är ett enkelt exempel på en klass i programspråket Python.<br>
<pre>
// PYTHON KOD
class Foo:<br>
    def __init__(self, val):
        self.val = val
    def printVal(self):
        print(self.val)
obj1 = Foo(2)
&gt;&gt;&gt; obj1.printVal()
2
</pre></p>

<h3>Översatt till Go</h3>

<p>Samma funktionalitet i Go ser ut så här:<br>
(Obs det finns säkert andra sätt att skriva detta på. Kom gärna med korr).</p>

<p>Först behöver vi importera fmt package för att kunna skriva ut variabeldata.
<pre>
package main
import (
    &quot;fmt&quot;
)
</pre></p>

<h4>Struct istället för en klass</h4>

<p><strong>Go har som sagt inga klasser, <em>så istället för en klass</em> skapar vi en
ny type</strong>, vi kallar den Foo, och den är av typen <strong>struct</strong>.
<pre>
type Foo struct {
}
</pre></p>

<h4>Struct variabel istället för klassvariabel</h4>

<p>I Python exemplet hade klassen en klassvariabel kallad val, <code>self.val = val</code>.
Vi ger därför vår struct <code>Foo</code> en variabel, <code>val int</code>, vilket allstå är
en variabel av typen <code>int</code>.
<pre>
type Foo struct {
    val int
}
</pre></p>

<h4>Från metod till funktion</h4>

<p>Python exemplet har en metod (en klassfunktion) som heter <strong>printVal</strong>.<br>
Vid anrop returnerar metoden värdet hos den anropade instansens variabel <code>val</code>.</p>

<p>Go har som sagt inte några klasser, därför får vi lösa detta på ett annat sätt.<br>
För att replikerar denna funktionalitet i Go skapar vi <strong>en fristående funktion</strong>
<code>printVal</code> med en <strong>pekare mot structen Foo</strong>.
<pre>
func (f *Foo) printVal() {
}
</pre></p>

<h4>Skriv ut den interna variabeln</h4>

<p>Avslutningsvis så behöver funktionen hämta värdet på variabeln
val i structen Foo och skriva ut den med <code>fmt.Println</code>.
<pre>
func (f *Foo) printVal() {
    fmt.Println(f.val)
}
</pre></p>

<h4>Main avslutar exemplet</h4>

<p>Avslutningsvis behöver vi ha en <code>main</code> funktion som i detta fall motsvarar
den <code>__init__</code> metod vi hade i Python exemplet.
<pre>
func main() {
    // Vi hade också kunnat skrivit obj1 = new Foo(2)
    obj1 := Foo{2}
    // Följande skriver ut värdet 2 i terminalen.
    obj1.printVal()
}
</pre></p>

<h3>Avslutningsvis</h3>

<p>Okay, så detta är inte på något sätt märkvärdigt (eller kanske ens värt att blogga om). Men jag hade själv lite svårt för övergången från OOP till icke-OOP, så jag tyckte att det kunde vara käckt att ha detta nedskrivet någonstans.</p>

<p>Om något kan förbättras eller är direkt fel, så är det mycket uppskattat om du lämnar en kommentar eller mailar mig!</p>

<h4>Koden i sin helhet</h4>

<pre>
// PYTHON KOD
class Foo:  
    def __init__(self, val):
        self.val = val
    def printVal(self):
        print(self.val)
obj1 = Foo(2)
\>>> obj1.printVal()
2
</pre>

<pre>
// GO KOD
package main
import (
    "fmt"
)
type Foo struct {
    val int
}
func (f *Foo) printVal() {
    fmt.Println(f.val)
}
func main() {
    obj1 := Foo{2}
    obj1.printVal()
}
</pre>

	  ]]></description>
	</item>

	<item>
	  <title>Go-Light <br>&mdash; en LightStreamer klient</title>
	  <link>//lightstreamer</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-11T15:08:00+01:00</pubDate>
	  <guid>//lightstreamer</guid>
	  <description><![CDATA[
	     <p>IG erbjuder automatiserade interaktioner med deras servrar genom ett REST-baserat API.
För strömdata använder sig IG en websocket-lösning som kallas Lightstreamer.
Lightstreamer gör det möjligt för en klient att
via HTTP/HTTPS öppna en sk &#39;ström kanal&#39; till
en Lightstreamer server. Från denna server kan klienten
sedan ta emot realtidsdata, så som i vårt fall kan vara
det senaste priset på FING.</p>

<p>Vi upprättar alltså en web socket server-klient koppling
för att ta emot realtidsdata från IG&#39;s server.
Det ger oss möjligheten att bland annat hämta marknadsdata, öppna och stänga positioner, och en hel del annat.</p>

<p>I denna post bekantar jag mig med hur man kan interagera
med IG&#39;s server genom programspråket Go.</p>

<blockquote>
<p>Mycket av innehållet i denna post går att läsa sig till
i Lightstreamer dokumentationen. För en mer ingående
beskrivning rekomenderar jag att man läser den.</p>

<p>Det blir omständigt att hela tiden göra översättningar så
jag använder ofta det engelska namnet på många begrepp, koncept
eller teknologier....exempelvis <em>stream connection</em> istället för
<em>strömkoppling</em>.</p>
</blockquote>

<h2>Lightstreamer - strömdata över HTTP</h2>

<p>För att i realtid kunna ta emot marknadsdata och öppna/stänga
positioner på IGs servrar, så behöver jag öppna en HTTP (över TCP)
eller HTTPS (HTTP över SSL) websocket connection.</p>

<p>Genom denna websocket kan jag sedan authenticera mig så att
jag kommer åt min Depå. När jag gjort detta kan jag sedan
öppna ytterligare en connection - en control connection genom
vilken jag kan sända kommandon till IGs Lightstreamer-servrar.
Med hjälp av dessa kommandon kan jag administrera/styra innehållet
i min stream connection.</p>

<p>Det kommunikationsprotokoll vi använder oss av kallas</p>

<h3>Text Mode</h3>

<p>Lightstreamer erbjuder två olika kommunikationsprotokol
när en klient vill kommunicera med en server:
<em>JavaScript Mode</em> och <em>Text Mode</em>.</p>

<p>I Text Mode packeteras realtidsuppdateringar genom ett enkelt pipe-separerat (&#39;|&#39;), text-protokoll.
I denna post koncentrerar jag mig just på <em>Text Mode</em>.</p>

<h3>HTTP/HTTPS Requests</h3>

<p>All kommunikation med IGs Lightstreamer servrar sker alltså över HTTP eller HTTPS.
De två tillgängliga <em>request</em>-metoderna för HTTP kommunikation är <strong>POST</strong> och <strong>GET</strong>.</p>

<p>Jag använder <strong>HTTP</strong> för alla <em>control connections</em> då dessa requests saknar känsligt
innehåll och främst är till för att administrera strömkopplingarna.</p>

<p><strong>HTTPS</strong> bör användas för all data som är känslig och därför bör krypteras.
Det kan rör sig om marknadsdata från IGs servrar till mig, eller
mina användarkontouppgifter från mig till IGs servrar.</p>

<p>In enlighet med HTTP spec:en bör request-formen <strong>POST</strong> användas när en request
har sido-effekter på serversidan.</p>

<p><strong>GET</strong> requests är enklare och kan därför vara smidigare att använda under
testning.</p>

<h3>Servrar bakom en Load Balancer</h3>

<p>. p.5</p>

<p>På IGs hemsida finna några exempelklienter man kan ladda hem om man vill bekanta sig med hur interaktion med deras API kan gå till.
IG&#39;s klienter är främst skrivna i JavaScript, Java och Excel.</p>

<p>Eftersom att det tyvärr inte fanns någon klient för det programspråk jag helst använder (Go), så skrev jag en egen
Go-klient för att interagera med IG&#39;s LightStreamer servrar.</p>

<blockquote>
<p>Jag vill understryka att detta alltså varken är en klient skriven av Lightstreamer teamet eller IG själva. Jag skrev den för eget bruk och lämnar inga garantier för dessa funktionalitet, korrekthet eller prestanda.
Jag hade god hjälp av Lightstreamer klienten för Python när jag skrev min Go-klient.</p>
</blockquote>

<hr>

<h2>En rudimentär klient</h2>

<p>Denna klient är främst till för att visa på hur man kopplar upp sig till IG&#39;s
Lightstreamer server och genomför enklare interaktion.</p>

<h2>Om klienten</h2>

<p>Jag skrev den här klienten eftersom att Lightstream själva inte ännu erbjduer
en klient skriven i Go. Det finns klienter Java och Javascript.</p>

<h2>Workflow och Sessionstruktur</h2>

<p>Klienten gör i huvudsak följande:</p>

<ol>
<li>Kopplar upp sig mot en angiven Lightstreamer server och skapar en ny <a href="https://en.wikipedia.org/wiki/Session_(computer_science)">session</a>.</li>
<li>Upprättar en prenumeration på de objekt man önskar</li>
<li>Meddelar när klienten tar emot den real-tids-data som servern skickar</li>
<li>Avbryter prenumerationen när sessionen är klar</li>
<li>Bryter kopplingen mot servern</li>
</ol>

<p>Här nedan beskriver jag lite hur klientens kod ser ut.</p>

<h3><a name="abcd">Session</a></h3>

<p><strong>LSClient</strong> är en funktion som implementerar Lightstreamer Text Mode Protocol för
hantering av HTTP request och response för korrekt kommunikation mellan klienten och servern:</p>

<ol>
<li> func connect<br>
Upprätta en kontakt med servern och skapa en ny session.</li>
<li>  func disconnect<br>
Skicka en begäran till servern om att stänga sessionen.</li>
<li>  func subscribe<br>
Genomför en begäran (request) om att prenumerera på data från servern.</li>
<li>  func unsubscribe<br>
Avregistrera klienten (eller den prenumeratrions_nyckel det rör sig om) från servern.</li>
</ol>

<p>Så, hantering av sessionen (genom connect och disconnect) och hantering av prenumerationen av datan från servern (genom subscribe och unsubscribe).</p>

<h2>Subscriptions och Unsubscriptions</h2>

<p>För att kunna ta emot <em>realtidsuppdateringar</em> av t ex marknadsdata från IGs servrar
så måste jag skicka en <strong>subscription</strong> till servern - alltså tala om för servern:</p>

<ol>
<li>Vilka <strong>items</strong> data jag vill ha</li>
<li>Vilka samlingar av <strong>fält</strong> jag är intresserad av</li>
<li>Eventuellt även vilka <strong>data adapters</strong> som bidrar med de items jag är intresserad av.</li>
</ol>

<p>I en klient så är Subscription-funktionen den som sammanställer min begäran om vilken
data jag vill ha realtidsuppdateringar om.</p>

<p>När jag inte längre vill att IGs server skall skicka realtids-uppdateringar kring
en viss item, så talar jag om för servern att jag vill göra en <strong>unsubscribe</strong> av denna item.</p>

<hr>

<p>Abstraktionen innehåller prenumerationsdetaljer (<em>item names</em>, <em>field names</em>
    och <em>management mode</em>). Den specifierar även en <em>Data Adapter</em> som bidrar
    med alla <em>items</em></p>

<p>Vidare så underhåller den en intern lista som möjliggör registreringen av
generiska lyssnare (genom funktionen <em>addlistener</em>) som vill bli meddelade
när servern skickar ut realtids-uppdateringar.</p>

<p>När en <em>item</em> event skickas ut från servern så kommer Subscription funktionen
att meddela dessa vidare till de lyssnare som registrerats.</p>

<p>De huvudsakliga funktionerna är:</p>

<ul>
<li>  _decode<br>
Avkodar field value i enlighet med Lightserver Text Protocol spec:en.</li>
<li>  addlisterner<br></li>
<li>  notifyupdate<br>
Invokeras av LSClient varje gång Lightstreamer
server pushar ett nytt item event.</li>
</ul>

<p>Funktionen _decode hanterar även avkodning av de text meddelanden som servern
svarar med i enlighet med Lightserver Text Protocol spec.</p>

<h2>Uppkoppling mot IGs Lightstreamer server</h2>

<p>När vi vill koppla upp oss mot IGs Lightstreamer server så måste vi först
upprätta en ny <em>session</em>.</p>

<p>Detta gör vi genom att <em>LSClient</em> funktionen, som i sin tur tar hjälp av
<em>connect</em> funktionen.</p>

<p>LSClient tar två argument, IGs server adress och ett <em>Adapter Set</em> - vilket är</p>

<p>Här är ett exempel på detta:
<pre>
ig_lightstreamer_client = LSClient(&quot;http://push.lightstreamer.com:80&quot;, &quot;DEMO&quot;)
if err != nil {
    fmt.Println(&quot;Unable to connect to the IG Lightstreamer Server.&quot;)
}
else {
    ig_lightstreamer_client.connect()
}
</pre></p>

<h2>Subscribing</h2>

<p>Nästa steg är att upprätta en prenumeration (subscription)
som gör att IG&#39;s Lightstream server börjar sända en realtidsström
av data till vår klient.</p>

<p>För att åstadkomma detta behöver vi:</p>

<ol>
<li> Anropa Subscription funktionen (classen).<br>
Denna tar fyra argument.

<ul>
<li>  prenumarations formatet (&quot;MERGE&quot;)</li>
<li>  listan med artiklar vi vill prenumerera på</li>
<li>  listan med fält namn (field names)</li>
<li>  Data Adaptern (&quot;QUOTE_ADAPTER&quot;)</li>
</ul></li>
<li> Vi måste också upprätta en prenumerationslyssnare.<br>
Det gör vi med hjälp av funktionen <code>on_item_update</code>.
Denna funktion inkluderar eventuell aktion man vill avfyra
för varje ny artiel som uppdateras.
<strong>hade varit bra med ett exempel här!</strong></li>
<li> <code>on_item_update</code> anropas av Subscription funktionen med hjälp
en annan funktion <code>addListener</code>.</li>
<li> En subscribe funktion returnerar en prenumerations nyckel.
Denna används sedan för att både registrera prenumerationen
hos LSClient och för senare avregistrering.</li>
</ol>

<h2>Notifiering</h2>

<p>När väl prenumerationen mot IGs Lightstreamer server är aktiverad
så kan vi börja ta emot de realtids event som servern börjar pusha
genom den HTTP koppling vi upprättade under <a href="#abcd">konnektionsfasen</a>,  det första steget när vi startar en ny session.</p>

<h2>Koppla ifrån Servern</h2>

<p>Det är viktigt att koppla från servern på ett snyggt sätt.
Det gör vi med hjälp av <em>disconnect</em> metoden
<pre></p>

<h1>Disconnecting</h1>

<p>lightstreamer_client.disconnect()
</pre></p>

<h2>IG Data Adapter</h2>

<p>Okay, så vilken typ artiklar kan vi få från IGs Data Adapter?
Vilka fält(fields) kan vi läsa av och skicka vidare för hantering?</p>

<hr>

<h2>CLI Interagera med IG Lightstream servern</h2>

<p>I många avseende är det just en icke visuell interaktion
som är önskvärd -  gränssnitt</p>

<h3>Öppna en position</h3>

<h3>Stäng en position</h3>

<h3>Uppdatera en position</h3>

<h3>Implementera en Trailing Stop</h3>

<h3>Samla Live Data för post Analys</h3>

<h3>Styra interaktionen med en Konfigurationsfil</h3>

<h3>Alarm och email uppdateringar</h3>

<h3>Position Sizing genom Tröskel-Logik</h3>

<p>Vi kan stänga en position och sluta automattrada
ifall ett vist tröskelvärde överträffas.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Go på OS X</title>
	  <link>//installera-go-osx</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-10T11:28:00+01:00</pubDate>
	  <guid>//installera-go-osx</guid>
	  <description><![CDATA[
	     <p>Go är väldigt kinking kring hur och var det installeras på datorn.
Denna post är mest en minnesanteckning om hur jag installerat Go på min
Mac. Jag postar den här om någon sitter i samma sits.</p>

<blockquote>
<p>Innehållet i detta dokument är i prakten hämtat från
Golang dokumentet &quot;How to Write Go Code&quot;. Läs det för utförligare förklaringar.</p>
</blockquote>

<h2>Workspaces</h2>

<p>Det är viktigt att förstå att Go projektstrukturer bygger på tanken om publik kod
som delas till exempel på Github.</p>

<p>Go vill att dess källkod ligger inom ett sk workspace.
Ett workspace är en katalogstruktur som har följande tre kataloger i roten:</p>

<ul>
<li>  <strong>src</strong> : här lägger man källkoden för de prjokt man skriver, och de
 organiserat i sk <strong>packages</strong> och är ofta .git bevakade.</li>
<li>  <strong>pkg</strong> : package objekt</li>
<li>  <strong>bin</strong> : exekverbara kommandon</li>
</ul>

<p>När man skrivit sin kod så bygger go verktyget källkoden till packages
och installerar de resulterande binära filerna i <em>pkg</em> och <em>bin</em>.</p>

<p>Workspace katalogen innehåller projekt i form av <strong>repositories</strong>.
Varje repo innehåller i sin tur <strong>commands</strong> och <strong>libraries</strong>.
<pre>
bin/
    hello #command object
    outyet                              #command object
pkg/
    linux<em>amd64/
        github.com/pkothbauer/example/
            stringutil.a                #package object
src/
    github.com/pkothbauer/example
        .git/                           #git metadata
        hello/
            hello.go                    #command source
        outyet/
            main.go                     #command source
            main</em>test.go
        stringutil/
            reversestring.go            #package source
            reversestring_test.go       #test source
</pre></p>

<h3>Ditt Workspace rymmer flera projekt</h3>

<p>Det vanliga är att flera olika projekt (repositories) under ett och samma workspace.
De flesta Go programmerar bevarar all sin go källkod och dependencies i ett enda workspace.</p>

<h2>GOPATH</h2>

<p>GOPATH variabeln talar helt enkelt om var någonstans ditt workspace finns.
Det är den enda systemvariabeln som behöver sättas för att programmera i Go.</p>

<p>En vanlig plats att lägga ditt workspace är direkt under HOME katalogen,
$ export GOPATH=$HOME</p>

<p>Så här sätter du GOPATH:</p>

<pre>
$ mkdir $HOME/workspace
$ export GOPATH=$HOME/workspace
</pre>

<blockquote>
<p>Notera att ditt workspace <strong>inte</strong> skall vara lokaliserat på samma path som din Go installation.</p>
</blockquote>

<p>Av praktiska skäl (så att du direkt kan exikvera program som ligger här) kan det vara käckt att lägga till din go bin katalog till din PATH.</p>

<pre>$ export PATH=$PATH:$GOPATH/bin</pre>

<h2>Package paths</h2>

<p>Din källkod förvarar du som sagt i egna packages (projektpaket).
Det är viktigt att välja en base path som inte riskerar att krocka med Go&#39;s egna packages som tex &quot;fmt&quot; osv.</p>

<p>Många väljer sitt Github-konto som base path. Kom ihåg att du inte behöver publicera
den kod du lägger här - men det hjälper att organisera koden på ett bra sätt.</p>

<p>Så, skapa en katalog i ditt workspace i vilket du förvarar dina projekts källkod.
<pre>mkdir -p $GOPATH/src/github.com/patrickbergden</pre></p>

<h2>Skapa, Kompilera och Kör ditt program</h2>

<p>När du vill skapa ett nytt program gör du typiskt så här:</p>

<ol>
<li> Välj ett namn på ditt package, tex hello</li>
<li> Skapa katalogen inom ditt workspace<br>
<code>$ mkdir $GOPATH/src/github.com/patrickbergden/hello</code></li>
<li> Skapa nu en hello.go fil som kommer att innehålla din källkod.
<pre>
package main
import &quot;fmt&quot;
func main(){
fmt.Println(&quot;Hello!&quot;)
}
</pre></li>
<li><p>Nu kan vi bygga och installera programmet med
hjälp av go verktyget:<br>
<code>$ go install github.com/patrickbergden/hello</code>
(Har man definerat GOPATH så listar go verktyget
ut var koden ligger i vårt workspace.</p>

<p>Det betyder att vi kan köra koden oavsett var
vi befinner oss i systemet).
Detta procducerar en exekverbar binär fil som
placeras under $GOPATH/workspace/bin under namnet
hello.</p></li>
<li><p>Vi kan nu sluligen köra den exekverbara filen
med kommandot $GOPATH/bin/hello<br>
($GOPATH är alltså = $HOME/workspace)<br>
(eller om vi har lagt till $GOPATH/bin så kan
vi direkt köra $ hello)</p></li>
</ol>

<h2>Source control</h2>

<p>I detta läge kan det vara käckt att använda
source control.
<pre>
cd $GOPATH/src/github.com/patrickbergden/hello<br>
git init
git add hello.go
git commit -m &quot;initial commmit&quot;
</pre></p>

<h2>Libraries</h2>

<p>Kod som vi ofta vill använda i olika projekt läggs
lämligen i egna separata bibliotek (library).</p>

<p>Första steget är att get biblioteket ett namn.<br>
<code>$ mkdir $GOPATH/src/github.com/patrickbergden/strutil</code></p>

<p>Nu skapar vi en fil som vi döper till reverse.go.</p>

<pre>
package strutil

func Echo(s string) string {
    return s
}
</pre>

<p>Nu kan vi bygga packaget med<br>
<code>go build github.com/patrickbergden/strutil</code>  </p>

<p>Om vi använder install istället så får vi ett package
som läggs under $GOPATH/pkg.</p>

<p>Nu kan vi anropa biblioteket i annan kod.
<pre>
package main
import (
    &quot;fmt&quot;
    &quot;github.com/strutil&quot;
)
func main() {
    fmt.Println(&quot;echo &quot; + strutil.Echo(&quot;echo&quot;))
}
</pre></p>

<p>Obs, <code>go tool</code> kommer automatiskt att se om vi
importerar bibliotek och även installera dessa.</p>

<p>Kompileras detta får vi en strutil.a fil som läggs under   $GOPATH/pkg/darwin_amd64/github.com/patrickbergden/</p>

<h3>Något om package namn</h3>

<p>Konventionen är att ett packages namn är detta sista
namnet i dess sökväg / import väg.
Importeras packaget som &quot;crypto/rot13&quot; så förväntas
packaget heta rot13.</p>

<p>Exekverbara filer måste alltid använda &quot;package main&quot;.</p>

<p>Packages behöver inte ha unika namn inom vårt
workspace men path:en måste vara unik.</p>

<h2>Testing</h2>

<p>Har vi en fil som heter hello.go så kan vi testa
den genom att skapa en fil vi kallar hello_test.go.
Vi lägger alltså helt enkelt till _test.go.</p>

<p>I hello_test.go använder vi Go&#39;s interna testramverk
och dess funktion <code>func (t *testing.T)</code>.
Det gör vi genom att: <code>import &quot;testing&quot;</code>.</p>

<p>Vi testar funktioner genom att skapa en funktion
och döpa den till TestXXX, där XXX är namnet på
den fil vi vill testa.</p>

<p>Om en sådan funktion anropar t.Error eller t.Fail
så har testet misslyckats.</p>

<p>Nedan lägger vi till ett test till vårt strutil
bibliotek.</p>

<pre>
package strutil

import "testing"

func TestEcho(t *testing.T) {
    cases := []struct {
        in, want string
    }{
        {"Hello", "HelloHello"},
        {"123", "123123"},
        {"",""},
    }
    for _, c := range cases {
        got := Echo(c.in)
        if got != c.want {
            t.Error("Echo(%q) == %q, want %q", c.in, got, c.want)
        }
    }
}
</pre>

<p>Vi testar sedan genom att köra:<br>
<code>$ go test github.com/patrickbergden/strutil</code></p>

<p>(Kör man testet direkt i package katalogen räcker
det självklart med att skriva go test).</p>

<h2>Remote packages</h2>

<p>Det sista är packages som till exempel ligger på
Github. Vi kan hämta packaget genom kommandot<br>
<code>go get</code></p>

<p><code>$ go get github.com/patrickbergden/hello</code></p>

	  ]]></description>
	</item>


</channel>
</rss>
