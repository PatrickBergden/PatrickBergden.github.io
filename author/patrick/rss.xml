<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>github.com/patrickbergden/</title>
   
   <link>http://github.com/patrickbergden/</link>
   <description>Reflektioner kring investering i aktier, råvaror, kryptovalutor och om att njuta av livet i största allmänhet.</description>
   <language>en-uk</language>
   <managingEditor> Patrick Bergden</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Decred<br>&mdash;en ny kryptovaluta</title>
	  <link>//decred</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-03-02T11:59:00+01:00</pubDate>
	  <guid>//decred</guid>
	  <description><![CDATA[
	     <h2>Kommande poster</h2>

<blockquote>
<p>samtliga med Golang code på Github eller Go playground eller YouTube vid:</p>
</blockquote>

<ul>
<li>  Monte Carlo</li>
<li>  Go-SWIFT</li>
<li>  Elliptic Curve crypto</li>
<li>  Deep Learning</li>
<li>  Morad och Volume Profile trading</li>
<li>  NLP i Smart Contracts</li>
<li>  Ny bok - Bitcoin på Svenska</li>
<li>  Ny bok - Ethereum och Smarta Kontrakt</li>
<li>  Ny bok - Blockchain Bank (skinner hat tip)</li>
<li>  Ny bok - Colored Coins (Dorier)</li>
<li>  Ny post - Bitcoin på Låg nivå</li>
<li>  Skapa en egen kryptovaluta</li>
<li>  Central Banks krypto (RSCoin)</li>
<li>  DVP på blockkedjan</li>
<li>  Hur skapar man en exchange</li>
<li>  HTTP Request/response</li>
<li>  Elvine projekt</li>
<li>  Coffee-trindikit</li>
<li>  Go-Bitcoin</li>
<li>  Go-trindikit</li>
<li>  Trading view chat scrollspeed monitor</li>
<li>  NLTK port some functions to Go</li>
<li>  ChangeTip genom Go</li>
</ul>

<h4>Från metod till funktion</h4>

<p>Python exemplet har en metod (en klassfunktion) som heter <strong>printVal</strong>.<br>
Vid anrop returnerar metoden värdet hos den anropade instansens variabel <code>val</code>.</p>

<p>Go har som sagt inte några klasser, därför får vi lösa detta på ett annat sätt.<br>
För att replikerar denna funktionalitet i Go skapar vi <strong>en fristående funktion</strong>
<code>printVal</code> med en <strong>pekare mot structen Foo</strong>.
<pre>
func (f *Foo) printVal() {
}
</pre></p>

<h4>Skriv ut den interna variabeln</h4>

<p>Avslutningsvis så behöver funktionen hämta värdet på variabeln
val i structen Foo och skriva ut den med <code>fmt.Println</code>.
<pre>
func (f *Foo) printVal() {
    fmt.Println(f.val)
}
</pre></p>

<h2>Proof of Work - Proof of Stake Hybrid</h2>

<h2>Schnorr Digitala Signaturer</h2>

	  ]]></description>
	</item>

	<item>
	  <title>Programspråket Go <br>har ingen class</title>
	  <link>//transition-to-go</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-12T11:59:00+01:00</pubDate>
	  <guid>//transition-to-go</guid>
	  <description><![CDATA[
	     <p>Jag har använt objektorienterad programmering i
över 20 år (jag började med Java 1.1, 1996).</p>

<p>Nu vill jag absolut inte kalla mig själv någon
duktig programmerare, men OOP tänket sitter rätt
hårt när jag börjar tänka hur jag skall koda ett projekt.</p>

<p>Python, Java, C++, Ruby och Javascript är några av
det språk som har färgat mitt sätt att tänka i OOP.
Alla har saker jag gillar - och en del saker jag ogillar.</p>

<p>För några år sedan fick jag upp ögonen för Go, Googles
nya språk. Det såg mest ut som C och kändes konstigt nog
ganska &#39;omodernt&#39; i jämförelse med kändisspråken Python
och Ruby.</p>

<p>Efter att ha spenderat en hel del tid med en hyffsat
stor (för mig) Javascript kod, så började jag sakta
tröttna på att skriva i ett dynamiskt språk utan typ kontroll.</p>

<p>Det började kännas olustigt att helt enkelt inte veta,
eller ständigt behöva kontrollera, vad en variabel
var för något.</p>

<p>För ett tag sedan kom jag å tänka på det där hårt typade
språket jag läst om några år tidigare.</p>

<p>Go - kändes plötsligt helt självklart att lära sig.
Litet, hårt typat med en grym compiler, inbyggd concurrency
och ett komplett standardbibliotek.</p>

<h3>What? Har Go inga klasser?</h3>

<p>Två saker blev genast en tröskel när jag började lära mig Go.<br>
1. Go är hårt typat och kompilatorn är stenhård på detta.<br>
2. Go har inga klasser eller inheritance.  </p>

<p>I början kändes nummer 1 ganska tröttsamt, men man vande sig sakta
och numera känns det bara skönt att veta att kompilatorn håller koll.
Nummer 2 däremot lämnade mig med en känsla av:</p>

<blockquote>
<p>&quot;Hur fan skriver man ett program utan klasser?&quot;</p>
</blockquote>

<p>Om du som läser detta undrat samma sak så hoppas jag att du kanske blir
hjälpt av att se ett exempel på hur man kan &#39;överstätta&#39; en Python klass
till samma funktionalitet i Go (alltså utan klasser).</p>

<h3>Klasser i Python</h3>

<p>Här är ett enkelt exempel på en klass i programspråket Python.<br>
<pre>
// PYTHON KOD
class Foo:<br>
    def __init__(self, val):
        self.val = val
    def printVal(self):
        print(self.val)
obj1 = Foo(2)
&gt;&gt;&gt; obj1.printVal()
2
</pre></p>

<h3>Översatt till Go</h3>

<p>Samma funktionalitet i Go ser ut så här:<br>
(Obs det finns säkert andra sätt att skriva detta på. Kom gärna med korr).</p>

<p>Först behöver vi importera fmt package för att kunna skriva ut variabeldata.
<pre>
package main
import (
    &quot;fmt&quot;
)
</pre></p>

<h4>Struct istället för en klass</h4>

<p><strong>Go har som sagt inga klasser, <em>så istället för en klass</em> skapar vi en
ny type</strong>, vi kallar den Foo, och den är av typen <strong>struct</strong>.
<pre>
type Foo struct {
}
</pre></p>

<h4>Struct variabel istället för klassvariabel</h4>

<p>I Python exemplet hade klassen en klassvariabel kallad val, <code>self.val = val</code>.
Vi ger därför vår struct <code>Foo</code> en variabel, <code>val int</code>, vilket allstå är
en variabel av typen <code>int</code>.
<pre>
type Foo struct {
    val int
}
</pre></p>

<h4>Från metod till funktion</h4>

<p>Python exemplet har en metod (en klassfunktion) som heter <strong>printVal</strong>.<br>
Vid anrop returnerar metoden värdet hos den anropade instansens variabel <code>val</code>.</p>

<p>Go har som sagt inte några klasser, därför får vi lösa detta på ett annat sätt.<br>
För att replikerar denna funktionalitet i Go skapar vi <strong>en fristående funktion</strong>
<code>printVal</code> med en <strong>pekare mot structen Foo</strong>.
<pre>
func (f *Foo) printVal() {
}
</pre></p>

<h4>Skriv ut den interna variabeln</h4>

<p>Avslutningsvis så behöver funktionen hämta värdet på variabeln
val i structen Foo och skriva ut den med <code>fmt.Println</code>.
<pre>
func (f *Foo) printVal() {
    fmt.Println(f.val)
}
</pre></p>

<h4>Main avslutar exemplet</h4>

<p>Avslutningsvis behöver vi ha en <code>main</code> funktion som i detta fall motsvarar
den <code>__init__</code> metod vi hade i Python exemplet.
<pre>
func main() {
    // Vi hade också kunnat skrivit obj1 = new Foo(2)
    obj1 := Foo{2}
    // Följande skriver ut värdet 2 i terminalen.
    obj1.printVal()
}
</pre></p>

<h3>Avslutningsvis</h3>

<p>Okay, så detta är inte på något sätt märkvärdigt (eller kanske ens värt att blogga om). Men jag hade själv lite svårt för övergången från OOP till icke-OOP, så jag tyckte att det kunde vara käckt att ha detta nedskrivet någonstans.</p>

<p>Om något kan förbättras eller är direkt fel, så är det mycket uppskattat om du lämnar en kommentar eller mailar mig!</p>

<h4>Koden i sin helhet</h4>

<pre>
// PYTHON KOD
class Foo:  
    def __init__(self, val):
        self.val = val
    def printVal(self):
        print(self.val)
obj1 = Foo(2)
\>>> obj1.printVal()
2
</pre>

<pre>
// GO KOD
package main
import (
    "fmt"
)
type Foo struct {
    val int
}
func (f *Foo) printVal() {
    fmt.Println(f.val)
}
func main() {
    obj1 := Foo{2}
    obj1.printVal()
}
</pre>

	  ]]></description>
	</item>

	<item>
	  <title>Schnorr Digitala Signaturer</title>
	  <link>//schnorr-signaturer-decred</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-11T15:08:00+01:00</pubDate>
	  <guid>//schnorr-signaturer-decred</guid>
	  <description><![CDATA[
	     <h2>Från bläck och papper...</h2>

<p>Detta Att signera dokument och beslut har människan gjort i hundratals år.
I bilden ovan signerar Amerikanska Senatorer <strong>The Constitution</strong> vilket
gav staterna en enad lag.</p>

<p>Varje senator signerade alltså med en penna ett pappersdokument (konstitutionen) - handlingen legitimerade och gav dokumentet juridisk betydelse.</p>

<h3>...till datorer och hemligheter</h3>

<p>Datoriseringen av världen sker med accelererande hastighet.
Allt fler beslut fattas via email och telefonsamtal.
Denna värld skapar ett behov av att kunna signera saker digitalt.</p>

<p>Inom, tex kryptovalutor som Bitcoin är det viktigt att veta vem som skickar ett meddelande. Tekniken för att säkerställa detta kallas <a href="https://en.wikipedia.org/wiki/Digital_signature">Digitala Signaturer</a>.
Bitcoin använder idag en variant av digital signatur som kallas Elliptisk Kurvatur Kryptografi. <a href="www.gp.se">Jag har tidigare skrivit en post och ett program som beskriver hur denna version av digitala signering går till</a>.</p>

<h2>Digitala signaturer</h2>

<p>Ett mycket vanligt behov på Internet är att kunna bekräfta att den part (person, organisation etc) som skickat ett meddelande, faktiskt är den de utger sig för att vara.</p>

<p>Så, signeringens värde ligger främst hos mottagaren av meddelandet och dennes
behov att kunna bekräfta att meddelandets avsändare är den hon utger sig för att vara.</p>

<p>Denna post är alltså en mindre teknisk post där jag ger mig på att förklara hur digitala signaturer fungerar - och då främst <a href="https://en.wikipedia.org/wiki/Schnorr_signature"><strong>Schnorr Digital Signatur</strong></a>.
Beskrivningen/definitionen som finns på Wikipediasidan kan nog upplevas
som <em>helt galet torr!</em>, men där finns i alla fall allt förklarat, med matematisk stringens.</p>

<blockquote>
<p>I slutet av denna post tänkte jag ge mig på att skapa en påhittad egen minikonstitution, skriva under den och skicka den till två andra parter som gör detsamma.
Lite som en modern version av bilden på signeringen av The Constitution.</p>
</blockquote>

<h3>Schnorr Digitala Signaturer</h3>

<p>Det finns flera olika varianter av signatur schema som baseras på <em><a href="www.gp.se">diskreta logaritmer</a></em>
En huvudsaklig fördel med <em>Schnorr digital signatur</em> är <strong>hastighet</strong>, jämte andra, är att merparten av beräkningen kan göras <strong>innan</strong> man sänder meddedlandet.
Detta skyndar på processen när man faktiskt vill skicka meddelandet.</p>

<p>Det finns olika versioner av denna algoritm, bland annat den som bygger på elliptiska
kurvor och <em>finite fields</em> varianten.
I denna post väljer jag att använda mig av den allmäna versionen.</p>

<p>När kan detta vara av värde?</p>

<blockquote>
<p>Ja, en jämförelse skulle kunna vara tiden det tar för 10 personer att lägga i ett brev i en brevlåda. Om alla man redan har skrivit adressen och frankerat brevet innan man ställer sig i kön går det väldigt mycket snabbare än om alla skall vänta på att nästa person vid brevlådan skriver adress och slickar på ett frimärke innan de lägger brevet på lådan.</p>
</blockquote>

<h3>Implementering i programkod</h3>

<p>Teori är super, men personligen har jag svårt att förstå teori om jag inte implementerar
den i något konkret. I denna post lägger jag efter varje sektion in källkod.</p>

<p>Den koden representerar alltså då teorin implementerad.
Det kompletta programmet i sin helhet, återfinns i slutet av posten.</p>

<p>Jag har även lagt programmet på min GitHub sida - men kom ihåg att detta bara är <a href="">throw-away-code</a>
och inte på något sätt tänkt att användas i något skarpt.</p>

<hr>

<h2>Schnorr Algoritmen</h2>

<p>Här nedan går jag igenom hela processen med att signera något med en Schnorr
digital signatur. För den som inte är superförtjust i Matematik - och då framför allt Modulär Aritmetik och Algebraiska Strukturer - <a href="#cheeryouup">så har jag skrivit några ord som kanske kan motivera lite grann</a><sup>*</sup>.</p>

<h3>Att välja Parametrar</h3>

<p>Alla användare av signatur <a href="www.gp.se">schemat</a> kommer överens om en mängd $G$ med generatorn $g$ av primtalsorder $q$ i vilket det diskret logaritmiska problemet är svårt.</p>

<blockquote>
<p>All users of the signature scheme agree on a group G with generator g of prime order q in which the discrete log problem is hard.</p>
</blockquote>

<p>Följande parameterar ingår i <em>Schnorr Digital Signatur</em>:<br>
$p, q, g, s, v, r, x, y$</p>

<p>Dessa parametrar representerar:</p>

<ul>
<li>  $p$: ett stort primtal (ofta representerad med ett 1024 bit tal) som är tillgängligt för alla.</li>
<li>  $q$: en stor <a href="http://www.mathsisfun.com/definitions/factor.html">primtalsfaktor</a> av $p-1$  (ofta representerad med ett 160 bit tal) och som är tillgänglig för alla.</li>
<li>  $g$: ett heltal med $order\;q\;modulo\;p,\;i\;[1, \cdot\cdot\cdot, p-1]$,<br>(i själva verket en <a href="https://crypto.stanford.edu/pbc/notes/numbertheory/gen.html">generator</a>) som uppfyller $a^q = 1\,mod\,p$</li>
</ul>

<p>Dessa tre värden, $p,q$ och $g$, kallas tillsammans <strong>publika</strong>. Man kan betrakta dem som en mängd kända värden som användarna av signaturen kommit överens om att använda.</p>

<blockquote>
<p>In modular arithmetic, a branch of number theory, a number g is a primitive root modulo n if every number a coprime to n is congruent to a power of g modulo n. That is, for every integer a coprime to n, there is an integer k such that gk ≡ a (mod n). Such k is called the index or discrete logarithm of a to the base g modulo n.<br>In other words, g is a generator of the multiplicative group of integers modulo n.</p>
</blockquote>

<h4>Källkod: Parametrar</h4>

<pre>
package main

import (
    "fmt"
    "math"
)

// Överenskomna parametrar
// p: ett primtal
var p int = 607
// q: en faktor i p-1
//var q int = 101
// g: en generator(funktion)
var g int = 601
</pre>

<hr>

<h3>Key generation</h3>

<p>Nu behöver vi ett <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">nyckelpar</a>:</p>

<ul>
<li><p><strong>Private key, x</strong><br>
$x$: ett heltal där $0 &lt; x &lt; q$, denna parameter representerar vår <em>privata signeringsnyckel</em> och väljs ur <em>den tillåtna mängden</em><br>$$x\in Z_x^q$$</p></li>
<li><p><strong>Public key, y</strong><br>
$y$: är $a^{-s} \,mod \,q$, detta värde är vår <a href="https://en.wikipedia.org/wiki/Public-key_cryptography"><em>publika nyckel</em></a>.<br>
Vi behöver räkna fram vår <em>public verification key</em>: $$y = g{^x} \; (mod\,p)$$</p></li>
</ul>

<h4>Viktigt att tänka på</h4>

<p>Vi får inte dela $x$ med någon annan för då kan de signera i vårt namn.
Den <strong>publika nyckeln</strong> är vad vi delar med oss på Internet. Den gör det möjgligt för andra att <a href="">bekräfta</a> vår signatur.</p>

<h4>Källkod: Key Generation</h4>

<pre>
// Private Key
// Välj ett slumptal x, sådant att 0 < x < q
//var x int = rand.Intn(q)
var x int = 3

// Public Key
// Räkna fram en public key sådan att y=g^x (mod p)
var y, gx int
gx = int(math.Pow(float64(g), float64(x)))
y = int(math.Mod(float64(gx), float64(p)))
</pre>

<hr>

<h3>Signering</h3>

<p>För att signera ett meddelande, $M$, så behöver vi gå igenom följande steg:</p>

<ul>
<li>  Välja ett slumptal $k$ från den tillåtna mängden, sådant att $$0 &lt; k &lt; q$$</li>
<li>  Vi använder sedan detta $k$ för att beräkna<br>$$r = g{^k}  \; (mod\,p)$$</li>
<li>  I nästa steg behöver vi konkatenera (slå ihop) meddelandet som skall signeras, $M$, med vårt beräknade värde, $r$, från steg (4).
<br>Värdet $r$ behöver vara representerat som en <a href="www.gp.se">bit sträng</a>.<br><br>Konkateringsnotationen, $||$, betyder allstå att vi slår ihop två tal.<br>
Resultatet av konkateneringen skall slutligen omvandlas till ett heltal med hjälp av <a href="https://sv.wikipedia.org/wiki/Hashfunktion">en envägs kryptografisk hash funktion</a> sådan att
$H:\{ 0,1 \}^*\rightarrow \mathbb $</li>
</ul>

<!-- \{0,1\}^*\leftarrow \Bbb_q$ <br> -->

<!-- $$e = H(M\,||\,r)$$ -->

<ul>
<li>  Det sista steget i signeringen är att beräkna <br>
$$s = r\, +\, x \cdot e\, (mod\, q)$$<br></li>
</ul>

<h5>Signaturen</h5>

<p>Vår Schnorr Digitala Signatur är nu paret: $(e,s)$</p>

<h4>Källkod: Signering</h4>

<pre>
// Välja ett slumptal r, sådant att 0 < r < q
var r int = rand.Intn(q)
</pre>

<hr>

<h3>Skicka</h3>

<p>Det vi skickar är två saker:</p>

<ol>
<li> Meddelandet, $M$</li>
<li> Signaturen, $(e,y)$, i den ordningen</li>
</ol>

<p>På detta sätt har mottagaren av meddelandet vad de behöver
för att <strong>verifiera</strong> signaturens riktighet.</p>

<blockquote>
<p>Vi försöker alltså inte att dölja meddelandet. Vi vill bara att
mottagaren skall kunna <em>verifiera</em> att det faktiskt är vi som
skickat meddelandet, inte någon oärlig tredje part.</p>
</blockquote>

<h4>Källkod: Skicka</h4>

<pre>
// p: ett primtal, ofta representerad med ett 1024 bit tal
var p int64
</pre>

<hr>

<h3>Verifiering</h3>

<p>Säg nu att jag signerat <em>ett meddelande</em>, $M$, och skickat detta tillsammans med <em>min signatur</em>, $(e,y)$, till ämnad mottagare.</p>

<p>I nästa steg vill i så fall mottagaren, efter att denne mottagit meddelande, <strong>verifiera</strong> att meddelandet faktiskt kommer från mig.
Tills sin hjälp i verifieringsprocessen har mottagaren alltså:</p>

<ul>
<li>  De mottagna meddelandet, $M$</li>
<li>  Avsändarens signatur, $e, y$</li>
<li>  De publika värdena: $p,q,a$</li>
<li>  Min publika nyckel: $v$</li>
</ul>

<p>Det första mottagaren behöver beräkna är:
$$x&#39; = a{^y}v{^e}\,mod\,p$$</p>

<p>Vi kan förenkla uttrycket. Först genom att byta ut $v$, vår publika nyckel, mot $a{^-s}$ från parameterlistan.</p>

<p>$$x&#39; = a{^y}v{^e} = a{^y}a{^-se}$$</p>

<p>Med enkla                               algebraiska regler kan vi samla exponenterna...</p>

<p>$$x´ = a{^y-se} = a{^r} = x\, mod\, p$$</p>

<p>Kom ihåg att $x$ var det värde vi slog ihop, eller konkatenerade, med meddelandet
och slutligen Hash:ade, i steg (4).</p>

<h4>Källkod: Verifiering</h4>

<pre>
// p: ett primtal, ofta representerad med ett 1024 bit tal
var p int64
</pre>

<hr>

<p>Det händer väldigt mycket på den här sidan av kryptografi, mycket på grund av
det stora intresset för kryptovalutor som <strong>Bitcoin</strong>.</p>

<p>I hjärtat av dessa kryptovalutor hittar vi idéen om en digital signatur.
Enkelt uttryckt - för att godkänna att något viktigt genomförs - som att flytta
alla mina Bitcoins från mitt koonto över till ditt konto - så kan jag kräva att
min digitala signatur &#39;signerar&#39;/godkänner denna process.</p>

<p>Den historiska bilden ovan visar händelsen när man i USA signerarade
<strong>The Constitutionen</strong>  - en mycket viktig händelse i USA&#39;s historia.</p>

<p>Just på grund av att detta var så viktigt så kan man förstå att politikernas
signaturer krävdes för att legitimera processen med att göra Constitution
allmängiltlig.</p>

<p>I dagsläget lever vi i en digital Internet-orienterad värld. En signatur måste
klara av en mängd olika typer av bedrägerier för att parterna i en process skall
våga lita på att rätt person givit sitt godkännande för att en process genomförs.</p>

<hr>

<p><a name="cheeryouup"></a><p></p><br></p>

<h3>Några ord om matematik och formalism:</h3>

<p>Jag har aldrig varit bra på matematik. Tvärtom - jag är en väldigt visuell person som alltid fått kämpa med skolans, i mitt tycke, torra oinspirerande sätt att lära
ut teoretiska ämnen.Om jag skall förstå något vill jag gärna börja med ett helhetsperspektiv och bilder - något som upprättar en känsla av att <em>det jag lär mig spelar roll i det mänskliga äventyret</em>.</p>

<p>Matematikundervisningen kan man tycka vad man vill om - jag tycker den är ofattbart primitiv - men om man haft en oinspirerande och onödigt invecklad introduktion av högre matematik (alltså allt ovan enklare funktioner och grundläggande algebra) så vill jag ge rådet: <em>Håll ut! Ge inte upp!</em></p>

<p>För mig är matematik som en ofattbart vass kniv. Ett instrument som skär rakt
ingenom människans närmast spontana behov av att svänga sig med ogentligheter och extremt ogrundade resonemang och representationer -  allt i ett försök att hantera vår komplexa värld (läs gärna <a href="">Nicholas Taleb&#39;s utmärka bok Black Swan</a> för mer om detta).</p>

<p>Med matematik kan vi ta oss fram och utforska denna extremt komplicerade värld, och faktiskt göra riktiga framsteg, värdefulla betraktelser som nästa generation kan nyttja och jobba vidare på.</p>

<p>Så ge inte upp, lär dig ett matematiskt verktyg i taget - ha alltid ett helikopterperspektiv av det Matematiska landskapet när du lär dig nya saker och
kom ihåg att Matematiken hjälper oss människor att &quot;come to grips&quot; med vår hysteriskt komplicerade värld. Sorry for the rant.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Go-Light <br>&mdash; en LightStreamer klient</title>
	  <link>//lightstreamer</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-11T15:08:00+01:00</pubDate>
	  <guid>//lightstreamer</guid>
	  <description><![CDATA[
	     <p>IG erbjuder automatiserade interaktioner med deras servrar genom ett REST-baserat API.
För strömdata använder sig IG en websocket-lösning som kallas Lightstreamer.
Lightstreamer gör det möjligt för en klient att
via HTTP/HTTPS öppna en sk &#39;ström kanal&#39; till
en Lightstreamer server. Från denna server kan klienten
sedan ta emot realtidsdata, så som i vårt fall kan vara
det senaste priset på FING.</p>

<p>Vi upprättar alltså en web socket server-klient koppling
för att ta emot realtidsdata från IG&#39;s server.
Det ger oss möjligheten att bland annat hämta marknadsdata, öppna och stänga positioner, och en hel del annat.</p>

<p>I denna post bekantar jag mig med hur man kan interagera
med IG&#39;s server genom programspråket Go.</p>

<blockquote>
<p>Mycket av innehållet i denna post går att läsa sig till
i Lightstreamer dokumentationen. För en mer ingående
beskrivning rekomenderar jag att man läser den.</p>

<p>Det blir omständigt att hela tiden göra översättningar så
jag använder ofta det engelska namnet på många begrepp, koncept
eller teknologier....exempelvis <em>stream connection</em> istället för
<em>strömkoppling</em>.</p>
</blockquote>

<h2>Lightstreamer - strömdata över HTTP</h2>

<p>För att i realtid kunna ta emot marknadsdata och öppna/stänga
positioner på IGs servrar, så behöver jag öppna en HTTP (över TCP)
eller HTTPS (HTTP över SSL) websocket connection.</p>

<p>Genom denna websocket kan jag sedan authenticera mig så att
jag kommer åt min Depå. När jag gjort detta kan jag sedan
öppna ytterligare en connection - en control connection genom
vilken jag kan sända kommandon till IGs Lightstreamer-servrar.
Med hjälp av dessa kommandon kan jag administrera/styra innehållet
i min stream connection.</p>

<p>Det kommunikationsprotokoll vi använder oss av kallas</p>

<h3>Text Mode</h3>

<p>Lightstreamer erbjuder två olika kommunikationsprotokol
när en klient vill kommunicera med en server:
<em>JavaScript Mode</em> och <em>Text Mode</em>.</p>

<p>I Text Mode packeteras realtidsuppdateringar genom ett enkelt pipe-separerat (&#39;|&#39;), text-protokoll.
I denna post koncentrerar jag mig just på <em>Text Mode</em>.</p>

<h3>HTTP/HTTPS Requests</h3>

<p>All kommunikation med IGs Lightstreamer servrar sker alltså över HTTP eller HTTPS.
De två tillgängliga <em>request</em>-metoderna för HTTP kommunikation är <strong>POST</strong> och <strong>GET</strong>.</p>

<p>Jag använder <strong>HTTP</strong> för alla <em>control connections</em> då dessa requests saknar känsligt
innehåll och främst är till för att administrera strömkopplingarna.</p>

<p><strong>HTTPS</strong> bör användas för all data som är känslig och därför bör krypteras.
Det kan rör sig om marknadsdata från IGs servrar till mig, eller
mina användarkontouppgifter från mig till IGs servrar.</p>

<p>In enlighet med HTTP spec:en bör request-formen <strong>POST</strong> användas när en request
har sido-effekter på serversidan.</p>

<p><strong>GET</strong> requests är enklare och kan därför vara smidigare att använda under
testning.</p>

<h3>Servrar bakom en Load Balancer</h3>

<p>. p.5</p>

<p>På IGs hemsida finna några exempelklienter man kan ladda hem om man vill bekanta sig med hur interaktion med deras API kan gå till.
IG&#39;s klienter är främst skrivna i JavaScript, Java och Excel.</p>

<p>Eftersom att det tyvärr inte fanns någon klient för det programspråk jag helst använder (Go), så skrev jag en egen
Go-klient för att interagera med IG&#39;s LightStreamer servrar.</p>

<blockquote>
<p>Jag vill understryka att detta alltså varken är en klient skriven av Lightstreamer teamet eller IG själva. Jag skrev den för eget bruk och lämnar inga garantier för dessa funktionalitet, korrekthet eller prestanda.
Jag hade god hjälp av Lightstreamer klienten för Python när jag skrev min Go-klient.</p>
</blockquote>

<hr>

<h2>En rudimentär klient</h2>

<p>Denna klient är främst till för att visa på hur man kopplar upp sig till IG&#39;s
Lightstreamer server och genomför enklare interaktion.</p>

<h2>Om klienten</h2>

<p>Jag skrev den här klienten eftersom att Lightstream själva inte ännu erbjduer
en klient skriven i Go. Det finns klienter Java och Javascript.</p>

<h2>Workflow och Sessionstruktur</h2>

<p>Klienten gör i huvudsak följande:</p>

<ol>
<li>Kopplar upp sig mot en angiven Lightstreamer server och skapar en ny <a href="https://en.wikipedia.org/wiki/Session_(computer_science)">session</a>.</li>
<li>Upprättar en prenumeration på de objekt man önskar</li>
<li>Meddelar när klienten tar emot den real-tids-data som servern skickar</li>
<li>Avbryter prenumerationen när sessionen är klar</li>
<li>Bryter kopplingen mot servern</li>
</ol>

<p>Här nedan beskriver jag lite hur klientens kod ser ut.</p>

<h3><a name="abcd">Session</a></h3>

<p><strong>LSClient</strong> är en funktion som implementerar Lightstreamer Text Mode Protocol för
hantering av HTTP request och response för korrekt kommunikation mellan klienten och servern:</p>

<ol>
<li> func connect<br>
Upprätta en kontakt med servern och skapa en ny session.</li>
<li>  func disconnect<br>
Skicka en begäran till servern om att stänga sessionen.</li>
<li>  func subscribe<br>
Genomför en begäran (request) om att prenumerera på data från servern.</li>
<li>  func unsubscribe<br>
Avregistrera klienten (eller den prenumeratrions_nyckel det rör sig om) från servern.</li>
</ol>

<p>Så, hantering av sessionen (genom connect och disconnect) och hantering av prenumerationen av datan från servern (genom subscribe och unsubscribe).</p>

<h2>Subscriptions och Unsubscriptions</h2>

<p>För att kunna ta emot <em>realtidsuppdateringar</em> av t ex marknadsdata från IGs servrar
så måste jag skicka en <strong>subscription</strong> till servern - alltså tala om för servern:</p>

<ol>
<li>Vilka <strong>items</strong> data jag vill ha</li>
<li>Vilka samlingar av <strong>fält</strong> jag är intresserad av</li>
<li>Eventuellt även vilka <strong>data adapters</strong> som bidrar med de items jag är intresserad av.</li>
</ol>

<p>I en klient så är Subscription-funktionen den som sammanställer min begäran om vilken
data jag vill ha realtidsuppdateringar om.</p>

<p>När jag inte längre vill att IGs server skall skicka realtids-uppdateringar kring
en viss item, så talar jag om för servern att jag vill göra en <strong>unsubscribe</strong> av denna item.</p>

<hr>

<p>Abstraktionen innehåller prenumerationsdetaljer (<em>item names</em>, <em>field names</em>
    och <em>management mode</em>). Den specifierar även en <em>Data Adapter</em> som bidrar
    med alla <em>items</em></p>

<p>Vidare så underhåller den en intern lista som möjliggör registreringen av
generiska lyssnare (genom funktionen <em>addlistener</em>) som vill bli meddelade
när servern skickar ut realtids-uppdateringar.</p>

<p>När en <em>item</em> event skickas ut från servern så kommer Subscription funktionen
att meddela dessa vidare till de lyssnare som registrerats.</p>

<p>De huvudsakliga funktionerna är:</p>

<ul>
<li>  _decode<br>
Avkodar field value i enlighet med Lightserver Text Protocol spec:en.</li>
<li>  addlisterner<br></li>
<li>  notifyupdate<br>
Invokeras av LSClient varje gång Lightstreamer
server pushar ett nytt item event.</li>
</ul>

<p>Funktionen _decode hanterar även avkodning av de text meddelanden som servern
svarar med i enlighet med Lightserver Text Protocol spec.</p>

<h2>Uppkoppling mot IGs Lightstreamer server</h2>

<p>När vi vill koppla upp oss mot IGs Lightstreamer server så måste vi först
upprätta en ny <em>session</em>.</p>

<p>Detta gör vi genom att <em>LSClient</em> funktionen, som i sin tur tar hjälp av
<em>connect</em> funktionen.</p>

<p>LSClient tar två argument, IGs server adress och ett <em>Adapter Set</em> - vilket är</p>

<p>Här är ett exempel på detta:
<pre>
ig_lightstreamer_client = LSClient(&quot;http://push.lightstreamer.com:80&quot;, &quot;DEMO&quot;)
if err != nil {
    fmt.Println(&quot;Unable to connect to the IG Lightstreamer Server.&quot;)
}
else {
    ig_lightstreamer_client.connect()
}
</pre></p>

<h2>Subscribing</h2>

<p>Nästa steg är att upprätta en prenumeration (subscription)
som gör att IG&#39;s Lightstream server börjar sända en realtidsström
av data till vår klient.</p>

<p>För att åstadkomma detta behöver vi:</p>

<ol>
<li> Anropa Subscription funktionen (classen).<br>
Denna tar fyra argument.

<ul>
<li>  prenumarations formatet (&quot;MERGE&quot;)</li>
<li>  listan med artiklar vi vill prenumerera på</li>
<li>  listan med fält namn (field names)</li>
<li>  Data Adaptern (&quot;QUOTE_ADAPTER&quot;)</li>
</ul></li>
<li> Vi måste också upprätta en prenumerationslyssnare.<br>
Det gör vi med hjälp av funktionen <code>on_item_update</code>.
Denna funktion inkluderar eventuell aktion man vill avfyra
för varje ny artiel som uppdateras.
<strong>hade varit bra med ett exempel här!</strong></li>
<li> <code>on_item_update</code> anropas av Subscription funktionen med hjälp
en annan funktion <code>addListener</code>.</li>
<li> En subscribe funktion returnerar en prenumerations nyckel.
Denna används sedan för att både registrera prenumerationen
hos LSClient och för senare avregistrering.</li>
</ol>

<h2>Notifiering</h2>

<p>När väl prenumerationen mot IGs Lightstreamer server är aktiverad
så kan vi börja ta emot de realtids event som servern börjar pusha
genom den HTTP koppling vi upprättade under <a href="#abcd">konnektionsfasen</a>,  det första steget när vi startar en ny session.</p>

<h2>Koppla ifrån Servern</h2>

<p>Det är viktigt att koppla från servern på ett snyggt sätt.
Det gör vi med hjälp av <em>disconnect</em> metoden
<pre></p>

<h1>Disconnecting</h1>

<p>lightstreamer_client.disconnect()
</pre></p>

<h2>IG Data Adapter</h2>

<p>Okay, så vilken typ artiklar kan vi få från IGs Data Adapter?
Vilka fält(fields) kan vi läsa av och skicka vidare för hantering?</p>

<hr>

<h2>CLI Interagera med IG Lightstream servern</h2>

<p>I många avseende är det just en icke visuell interaktion
som är önskvärd -  gränssnitt</p>

<h3>Öppna en position</h3>

<h3>Stäng en position</h3>

<h3>Uppdatera en position</h3>

<h3>Implementera en Trailing Stop</h3>

<h3>Samla Live Data för post Analys</h3>

<h3>Styra interaktionen med en Konfigurationsfil</h3>

<h3>Alarm och email uppdateringar</h3>

<h3>Position Sizing genom Tröskel-Logik</h3>

<p>Vi kan stänga en position och sluta automattrada
ifall ett vist tröskelvärde överträffas.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Privata Blockkedjor<br>&mdash; med MultiChain</title>
	  <link>//private-blockchains-multichain</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-11T15:08:00+01:00</pubDate>
	  <guid>//private-blockchains-multichain</guid>
	  <description><![CDATA[
	     <p>Can it get any easier than this?:</p>

<ol>
<li>Download Multichain</li>
<li>In the terminal: multichain-util create myAwesomeBlockchain</li>
<li>A new directory is created: ~/.multichain/myAwesomeBlockchain/</li>
<li>In the directory you&#39;ll find a settings file called params.dat</li>
<li>In the terminal, start the blockchain with: multichaind myAwesomeBlockchain -daemon
This will:
    lock the contents of params.dat
    initialize the blockchain
    cause the first block to be mined</li>
<li>A node address will be output to allow other nodes to easily connect</li>
</ol>

<p>So, how can others connect to myAwesomeBlockchain?
Well, if the myAwesomeBlockchain is private you have to grant them permission.
So, anyone who wants access to myAwesomeBlockchain have to:</p>

<ol>
<li>Try to connect to myAwesomeBlockchain</li>
<li>A message is written in their terminal containing their address</li>
<li>They need to send this address to you, myAwesomeBlockchain’s administrator</li>
<li>Once you give them permission, guests can connect to myAwesomeBlockchain using the short form:
multichaind myAwesomeBlockchain -daemon</li>
<li>Once connected to myAwesomeBlockchain their nodes will begin downloading and verifying
myAwesomeBlockchain, and discovering &amp; connecting to other nodes in the myAwesomeBlockchain network.</li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Go på OS X</title>
	  <link>//installera-go-osx</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-02-10T11:28:00+01:00</pubDate>
	  <guid>//installera-go-osx</guid>
	  <description><![CDATA[
	     <p>Go är väldigt kinking kring hur och var det installeras på datorn.
Denna post är mest en minnesanteckning om hur jag installerat Go på min
Mac. Jag postar den här om någon sitter i samma sits.</p>

<blockquote>
<p>Innehållet i detta dokument är i prakten hämtat från
Golang dokumentet &quot;How to Write Go Code&quot;. Läs det för utförligare förklaringar.</p>
</blockquote>

<h2>Workspaces</h2>

<p>Det är viktigt att förstå att Go projektstrukturer bygger på tanken om publik kod
som delas till exempel på Github.</p>

<p>Go vill att dess källkod ligger inom ett sk workspace.
Ett workspace är en katalogstruktur som har följande tre kataloger i roten:</p>

<ul>
<li>  <strong>src</strong> : här lägger man källkoden för de prjokt man skriver, och de
 organiserat i sk <strong>packages</strong> och är ofta .git bevakade.</li>
<li>  <strong>pkg</strong> : package objekt</li>
<li>  <strong>bin</strong> : exekverbara kommandon</li>
</ul>

<p>När man skrivit sin kod så bygger go verktyget källkoden till packages
och installerar de resulterande binära filerna i <em>pkg</em> och <em>bin</em>.</p>

<p>Workspace katalogen innehåller projekt i form av <strong>repositories</strong>.
Varje repo innehåller i sin tur <strong>commands</strong> och <strong>libraries</strong>.
<pre>
bin/
    hello #command object
    outyet                              #command object
pkg/
    linux<em>amd64/
        github.com/pkothbauer/example/
            stringutil.a                #package object
src/
    github.com/pkothbauer/example
        .git/                           #git metadata
        hello/
            hello.go                    #command source
        outyet/
            main.go                     #command source
            main</em>test.go
        stringutil/
            reversestring.go            #package source
            reversestring_test.go       #test source
</pre></p>

<h3>Ditt Workspace rymmer flera projekt</h3>

<p>Det vanliga är att flera olika projekt (repositories) under ett och samma workspace.
De flesta Go programmerar bevarar all sin go källkod och dependencies i ett enda workspace.</p>

<h2>GOPATH</h2>

<p>GOPATH variabeln talar helt enkelt om var någonstans ditt workspace finns.
Det är den enda systemvariabeln som behöver sättas för att programmera i Go.</p>

<p>En vanlig plats att lägga ditt workspace är direkt under HOME katalogen,
$ export GOPATH=$HOME</p>

<p>Så här sätter du GOPATH:</p>

<pre>
$ mkdir $HOME/workspace
$ export GOPATH=$HOME/workspace
</pre>

<blockquote>
<p>Notera att ditt workspace <strong>inte</strong> skall vara lokaliserat på samma path som din Go installation.</p>
</blockquote>

<p>Av praktiska skäl (så att du direkt kan exikvera program som ligger här) kan det vara käckt att lägga till din go bin katalog till din PATH.</p>

<pre>$ export PATH=$PATH:$GOPATH/bin</pre>

<h2>Package paths</h2>

<p>Din källkod förvarar du som sagt i egna packages (projektpaket).
Det är viktigt att välja en base path som inte riskerar att krocka med Go&#39;s egna packages som tex &quot;fmt&quot; osv.</p>

<p>Många väljer sitt Github-konto som base path. Kom ihåg att du inte behöver publicera
den kod du lägger här - men det hjälper att organisera koden på ett bra sätt.</p>

<p>Så, skapa en katalog i ditt workspace i vilket du förvarar dina projekts källkod.
<pre>mkdir -p $GOPATH/src/github.com/patrickbergden</pre></p>

<h2>Skapa, Kompilera och Kör ditt program</h2>

<p>När du vill skapa ett nytt program gör du typiskt så här:</p>

<ol>
<li> Välj ett namn på ditt package, tex hello</li>
<li> Skapa katalogen inom ditt workspace<br>
<code>$ mkdir $GOPATH/src/github.com/patrickbergden/hello</code></li>
<li> Skapa nu en hello.go fil som kommer att innehålla din källkod.
<pre>
package main
import &quot;fmt&quot;
func main(){
fmt.Println(&quot;Hello!&quot;)
}
</pre></li>
<li><p>Nu kan vi bygga och installera programmet med
hjälp av go verktyget:<br>
<code>$ go install github.com/patrickbergden/hello</code>
(Har man definerat GOPATH så listar go verktyget
ut var koden ligger i vårt workspace.</p>

<p>Det betyder att vi kan köra koden oavsett var
vi befinner oss i systemet).
Detta procducerar en exekverbar binär fil som
placeras under $GOPATH/workspace/bin under namnet
hello.</p></li>
<li><p>Vi kan nu sluligen köra den exekverbara filen
med kommandot $GOPATH/bin/hello<br>
($GOPATH är alltså = $HOME/workspace)<br>
(eller om vi har lagt till $GOPATH/bin så kan
vi direkt köra $ hello)</p></li>
</ol>

<h2>Source control</h2>

<p>I detta läge kan det vara käckt att använda
source control.
<pre>
cd $GOPATH/src/github.com/patrickbergden/hello<br>
git init
git add hello.go
git commit -m &quot;initial commmit&quot;
</pre></p>

<h2>Libraries</h2>

<p>Kod som vi ofta vill använda i olika projekt läggs
lämligen i egna separata bibliotek (library).</p>

<p>Första steget är att get biblioteket ett namn.<br>
<code>$ mkdir $GOPATH/src/github.com/patrickbergden/strutil</code></p>

<p>Nu skapar vi en fil som vi döper till reverse.go.</p>

<pre>
package strutil

func Echo(s string) string {
    return s
}
</pre>

<p>Nu kan vi bygga packaget med<br>
<code>go build github.com/patrickbergden/strutil</code>  </p>

<p>Om vi använder install istället så får vi ett package
som läggs under $GOPATH/pkg.</p>

<p>Nu kan vi anropa biblioteket i annan kod.
<pre>
package main
import (
    &quot;fmt&quot;
    &quot;github.com/strutil&quot;
)
func main() {
    fmt.Println(&quot;echo &quot; + strutil.Echo(&quot;echo&quot;))
}
</pre></p>

<p>Obs, <code>go tool</code> kommer automatiskt att se om vi
importerar bibliotek och även installera dessa.</p>

<p>Kompileras detta får vi en strutil.a fil som läggs under   $GOPATH/pkg/darwin_amd64/github.com/patrickbergden/</p>

<h3>Något om package namn</h3>

<p>Konventionen är att ett packages namn är detta sista
namnet i dess sökväg / import väg.
Importeras packaget som &quot;crypto/rot13&quot; så förväntas
packaget heta rot13.</p>

<p>Exekverbara filer måste alltid använda &quot;package main&quot;.</p>

<p>Packages behöver inte ha unika namn inom vårt
workspace men path:en måste vara unik.</p>

<h2>Testing</h2>

<p>Har vi en fil som heter hello.go så kan vi testa
den genom att skapa en fil vi kallar hello_test.go.
Vi lägger alltså helt enkelt till _test.go.</p>

<p>I hello_test.go använder vi Go&#39;s interna testramverk
och dess funktion <code>func (t *testing.T)</code>.
Det gör vi genom att: <code>import &quot;testing&quot;</code>.</p>

<p>Vi testar funktioner genom att skapa en funktion
och döpa den till TestXXX, där XXX är namnet på
den fil vi vill testa.</p>

<p>Om en sådan funktion anropar t.Error eller t.Fail
så har testet misslyckats.</p>

<p>Nedan lägger vi till ett test till vårt strutil
bibliotek.</p>

<pre>
package strutil

import "testing"

func TestEcho(t *testing.T) {
    cases := []struct {
        in, want string
    }{
        {"Hello", "HelloHello"},
        {"123", "123123"},
        {"",""},
    }
    for _, c := range cases {
        got := Echo(c.in)
        if got != c.want {
            t.Error("Echo(%q) == %q, want %q", c.in, got, c.want)
        }
    }
}
</pre>

<p>Vi testar sedan genom att köra:<br>
<code>$ go test github.com/patrickbergden/strutil</code></p>

<p>(Kör man testet direkt i package katalogen räcker
det självklart med att skriva go test).</p>

<h2>Remote packages</h2>

<p>Det sista är packages som till exempel ligger på
Github. Vi kan hämta packaget genom kommandot<br>
<code>go get</code></p>

<p><code>$ go get github.com/patrickbergden/hello</code></p>

	  ]]></description>
	</item>

	<item>
	  <title>Positionsdimensionering & <br> Anti Martingale Strategier</title>
	  <link>//positionsdimensionering</link>
	  <author>Patrick Bergden</author>
	  <pubDate>2016-01-01T11:18:00+01:00</pubDate>
	  <guid>//positionsdimensionering</guid>
	  <description><![CDATA[
	     <p>När jag började med trading gav någon mig rådet att istället direkt spola ner
mitt tradingkapital på toaletten - då skulle jag åtminstonne ha tiden
kvar till annat.</p>

<p>Och visst, trading är svårt - det märker man snabbt.
Ibland kan det kännas som att hela marknaden konspirerar för att ta just dina pengar. Det är helt klart en sink-or-swim-miljö, med många traders på havets botten.</p>

<p>En sak jag tidigt kände mig väldigt osäker kring, var hur stora positioner
jag skulle ta. I början sköt jag från höften och valde positionsstorlek på magkänsla. Newsflash: magkänsla och framgångsrik trading är ingen hit!</p>

<p>Med tiden började jag inse att skärpa inom området risk management var avgörande för om jag skulle ha en chans att hamna på rätt sida om den statistik som säger att 80-90% av alla traders misslyckas.</p>

<p>Så för någon vecka sedan bestämde jag mig för att lära mig hur man kan tänka kring positionsstorlekar i trading.
Resultatet är denna post.</p>

<p>Om du som läser detta blir hjälpt av innehållet, så blir jag naturligtvis glad. Tveka inte att skicka en rad om du har frågor eller upptäcker något som är fel eller kan förbättras. Jag är grymt tacksam för all feedback.</p>

<p>Obs 1, för att hålla beräkningarna enkla har jag valt att bortse från spreads, slippage och courtage-kostnader.</p>

<p>Obs 2, innehållet i denna post skall inte tas som rekomendationer.
Var och en får bilda sig sin egen uppfattning om hur de bäst vill förvalta och riskera sitt kapital.</p>

<hr>

<h2>Positionsdimensionering</h2>

<p>Okay så ett vanligare namn för detta område är Position Sizing, men jag väljer
här att använda mig av positionsdimensionering som term för:</p>

<ol>
<li>Att bestämma storleken på det kapital man väljer att riskera när man öppnar en position.</li>
<li>Att tänka kring faktorer som står i relation till positionsstorleken och hur vi kan ta hänsyn till dessa för att försöka gynsamt påverka utsikterna för en planerad trade.</li>
</ol>

<p>Med andra ord, när du läser positionsdimension så tänk - hur mycket kronor
av den totala tradingdepån man väljer att riskera i en viss trade.</p>

<hr>

<h2>Martingale Strategi</h2>

<p>Enkelt uttryckt så går denna strategi ut på att man dubblar sin risk varje gång
man förlorar.</p>

<p>Låt säga att vi spelar Roulette.
Om vi satar 1kr på rött och förlorar, så säger Martingale strategin att vi i nästa snurr skall dubbla vår risk och alltså satsa 2 kr.
Förlorar vi även denna gång så skall vi vid nästa snurr satsa dubbelt igen, alltså 4 kr.</p>

<p>Tanken är att när vi väl vinner så vinner vi tillbaks de tidigare förlusterna.
Problemet är främst att om vi har otur så hinner vi bränna vårt konto innan
kulan hamnar på vår satsade färg.</p>

<p>Precis som i roulette, så är det i trading omöjligt att säga hur många förlorande sviter vi kommer att innan vi får rätt (kursen går i vår önskade riktning).</p>

<p>Det är åtminstonne en anledning till att Martingale strategin kanske inte är supergrym för någon som vill förbättra sin risk management i trading.
Men det finns ett besläktat alternativ.</p>

<h2>Anti Martingale Strategi</h2>

<p>Denna strategi föreslår att vi istället ökar vår risk så länge vi vinner och
kursen går i vår önskade riktning.</p>

<p>Observera att vi inte uttryckligen säger att man måste dubble in risk.
Det räcker med att öka risken för att följa strategin.</p>

<p>I Roulette-exempelet ovan så blir alltså skillnaden att vi <strong>ökar</strong> vår risk
varje gång vi vinner. Exempel, satsar vi 1 krona och vinner så kan vi välja att
satsa 1.5kr vid nästa snurr.</p>

<p>På detta vis minskar risken avseevärt för att en förlorande svit skall äta upp
allt vårt kapital innan vi vinner igen.</p>

<h2>R som i Risk</h2>

<p>När jag tar en position innebär det att jag tittar på min tradingdepå och
avgör hur stor del av denna (i procent eller kronor) som jag vill riskera när jag
öppnar positionen.</p>

<p>Om jag handlar 50st aktier som kostar 100 kr styck, så blir min R (risk) 5000kr (100kr*50=5000kr).</p>

<h2>R-multipler</h2>

<p>Istället för att tala om profiter och förluster i kronor, så kan vi nu tala om R-multipler.</p>

<p>Om aktien ovan går upp och blir värd 400kr styck så kan jag istället för att tala om en profit på 50*(400-100)=15.000 kr, istället
betrakta det som att jag har en 3R profit (15.000/5.000=3).</p>

<p>Fördelen är att vi nu kan prata i största allmänhet om profit och förlust i form av R-Multipler.</p>

<pre>Exempel
Om R motsvarar 5 investerade kronor och marknaden går upp 30 kr då har du gjort en förtjänst på 6R (30/5=6).
Om R motsvarar 6 investerade kronor och marknaden går ner 60 kr då har du
en gjort en förlust på 10R (60/6=10).
</pre>

<p>Vi kan uttrycka förluster och förtjänster i form av R.
Köper vi 100 st aktier som kostar 10 kr styck så är risken 1000 kr.
Om vi senare säljer dessa aktier och gör en förtjänst på 40 000 kr så
kan vi säga att vi gjort en 40000/1000=40, 40R förtjänst.</p>

<p>Exempel: vi köper 100st FING aktier för 400 kr = 40 000 kr och sätter en stopp loss
på 2% - det vill säga att vi (om vi är long) placerar en stop limit order på 392 kr.
I detta fall är alltså R = 400 * 100 - 392 * 100 = 800 kr.</p>

<p>Du riskar 700 kr (R) och gör senare en profit på 2800 kr, detta motsvarar då en 4R profit (2800/700=4).</p>

<p>Du riskar 5000 kr (R) och gör senare en förlust på 2500 kr, detta motsvarar då en 0.5R (2500/5000=0.5) förlust.</p>

<p>Du riskar 50 kr per aktie och gör en
förlust på 100 kr per aktie, detta motsvarar då en 2R förlust (100/50=2).</p>

<p>Målsättningen är att ha stora R-Multiple profiter och max 1R förluster.</p>

<h4>Beräkna R-Multipler vid aktieköp</h4>

<ol>
<li>Först räknar jag ut hur mycket risk jag lägger.<br>
Detta blir min 1R.</li>
<li>Sedan multiplicerar jag 1R med antal aktier.</li>
<li>Nu räknar jag ut total profit (eller förlust) inklusive courtage.</li>
<li>Nu delar jag det värdet jag räknade ut i föregående steg med den initiala risken.</li>
<li>Till sist får jag R-Multipeln som en vinst eller förlust.</li>
</ol>

<h4>Hur många aktier skall jag köpa?</h4>

<p>Säg att jag handlar FING vid $23 per aktie, med en stopp loss på 25%.  </p>

<p>Det betyder att stop lossen är placerad vid:<br>
$23*0.25 = $5.75
$23-5.75 = $17,25 per aktie.  </p>

<p>Om jag nu väljer att riska 1% av mitt totala kapital, vi säger att det är 100 000 kr, så innebär det att jag skall handla $1000/5.75=174 FING-aktier till ett pris på $23, och en total summa i cash på $4 000 kr.  </p>

<p>Om aktien går ner 25% från $23 till
$17,25 så säljer vi.</p>

<h4>Vad blir R-Multipeln vid en profit?</h4>

<p>Om jag köpte 174 aktier för $23 och senare säljer dessa för $38 gör jag en
profit på $38<em>174 - $23</em>174 =  $2610.<br>
Nu delar jag denna summa med min risk för att få min R-Multipel:
$2610/$1000=2.61R profit.</p>

<h2>Expectancy</h2>

<p>Expectancy är ett mått på förväntat resultat i ett trading system.
Formeln är: Summa R-Multiples / Number of trades.</p>

<p>[1R, -2R, 4R, 1.1R, 3R] / 5 = 1.42 R</p>

<p>Det skulle betyda att varje investering som använder vårt tradingsystem bör
ge oss i genomsnitt 1.42 ggr profit på satsat kapital.</p>

<hr>

<!-- ### Strategier för att avgöra storleken på Global Positioner -->

<h2>Kapitalmodeller</h2>

<p>Så, nu är frågan - hur mycket kaptial skall jag satsa när jag bestämt mig för att
ta en position? Här är tre modeller.</p>

<h3>1. Totalt Kapital</h3>

<p>En enkel men antaligen för aggresiv modell är att helt enkelt satsa en fix procent av totalt kapital vid varje trade.</p>

<pre>
<mark>Exempel Total Kapital</mark>
Säg att jag har ett totalt kapital på 100 000 kr.
Låt oss även säga att jag bestämt mig för att alltid
riska 1% i mina trades.

Om jag nu vill ta en position i FING så betyder det
att jag skall köpa FING för 100 000*0.01 = 1 000 kr.

Senare på eftermiddagen ser jag att ERICA rör sig i den
riktning jag hoppats på och öppnar däför ytterligare en
postion.

Återigen riskar jag 1% av mitt totala kapital och öppnar
en position till ett värde av 1 000 kr.

Nu har jag två aktiva positioner med en sammanlagd risk
på 2000 kr och 100 000 - 2000 = 98 000 kr i cash.
</pre>

<p>Med andra ord - jag tar inte hänsyn till hur det går för mina öppna positioner när jag positionsdimensionerar.</p>

<p>Med tanke på att många trades blir förluster är detta
som sagt en ganska aggresiv modell.</p>

<h3>2. Core Kapital</h3>

<p>I denna modell bestämmer vi storleken på positionerna utifrån faktiskt
tillgänglig cash i vårt totala kapital.
Vi tar inte hänsyn till öppna positioner förräns de stängts.</p>

<pre>
<mark>Exempel Core Kapital</mark>

Totalt kapital: 100 000 kr  
Vi öppnar en position på 1% av det totala kapitalet:
100 000 * 0.01 = 1 000 kr  

När vi tagit vår position är tillgänglig cash:  
100 000 - 1 000 kr = 99 000 kr  

Nu öppnar vi ytterligare en position.
Även denna gång riskar vi 1% av totalt kapital.
Men denna gång blir det:
99 000 * 0.01 = 990 kr

När vi tagit vår andra position är tillgänglig cash:  
99 000 - 990 kr = 98 010 kr.
</pre>

<p>Att tänka på - vi betraktar våra öppna positioner som förlorat kapital fram tills dess att vi stängt positionen (till vinst eller förlust).</p>

<p>Det kan vara ett bra sätt att tänka kring placeringar och tillgängligt kapital.
Så vi antar helt enkelt att det kapital som investerats i olika positioenr
är förlorat fram till dess att vi stängt positionen.</p>

<h3>3. Reducerat Totalt Kapital</h3>

<p>Även denna model bygger på tillgänglig cash, men tar hänsyn till de pengar vi låser in när vi flyttar våra stopp lossar.</p>

<p>I likhet med Core modellen räknar vi kapital i öppna
possitioner som förlorade - med till skillnad från Core så blir dessa pengar återigen en del av vårt totala kapital om/när vi flyttar våra stopp lossar så att risken blir starkt minimerad.</p>

<pre><mark>Exempel Reducerat Totalt Kapital</mark>  
Säg att jag börjar med ett totalt kapital på 100 000 kr.
Jag tar en position på 1% av detta totala kapital,
dvs 1 000 kr.  

Säg nu att aktiekursen börjar gå min väg.
Jag sätter i så fall en stopp loss som gör att jag
går ur om jag förlorar 500 kr
(tex 100 st aktier för 1 kr med en stopp loss
på 0.50 kr).  

Positionens storlek: 1000 kr
Stopp lossen är satt vid 500 kr, det vill säga att jag
säljer om positionens värde går ner till 500 kr.  

10 st aktier till priset av 100 kr = 1000 kr
Priset går ner till 50 kr -> 10*50 kr = 500 kr
</pre>

<p>I Core hade vi räknat total kapital till 99 000 kr
I Core blir det istället 99500 kr</p>

<hr>

<h2>Skala in positioner med Anti Martingale Strategin</h2>

<p>Strategin är enkel:</p>

<ul>
<li>  När en aktie går upp 25% från det pris vi köpte den för
så öppnar vi ytterligare en position i samma aktie.</li>
<li>  Vi riskar då ytterligare risk, vars storlek då styrs av vilken kapitalmodell vi föredrar (se ovan).</li>
<li>  Vi gör detta upp till fyra gånger.</li>
</ul>

<pre>
<mark>Exempel Skala in Position</mark>  
Säg att jag har ett Total Kapital på 100 000 kr.  

Jag bestämer mig för att riska 1% av detta totala
kapital, alltså 1 000 kr.

Jag väljer att följa Core Kapitalmodellen när jag
beräknar hur mycket jag skall riska i nästföljande positioner.  

Min trailing stopp loss sätter jag på 25% - alltså
en bred stopp.

Jag börjar med att köpa FING när den kostar 460 kr
per aktie.

Det betyder att jag skall köpa:
1000/(460*0.25) = 8 aktier
till ett pris på 8*460 = 3680 kr

Säg nu att aktiens pris ökar med 25% upp till
460 * 1.25 = 587,50 kr.
Jag öppnar (skalar in) ytterligare en 1% position.  

Då jag valt att använda Core Kapitalmodellen så
skall jag köpa:  
100 000 - 1000 = 99 000 kr
99 000 * 0.01 = 990 kr  
990 / (587,50 * 0.25) = 6.74 ≈ 6 aktier,
för en totalsumma på 6 * 587,50 ≈ 3525 kr
</pre>

<p><a href="https://www.tradingview.com/x/nCIAgnlQ"><img src="/assets/images/fing_03.png" ></img></a></p>

<table><thead>
<tr>
<th>Totalt Kapital</th>
<th style="text-align: center">Pris</th>
<th style="text-align: right">Aktier</th>
<th style="text-align: right">Värde</th>
</tr>
</thead><tbody>
<tr>
<td>100 000</td>
<td style="text-align: center">23</td>
<td style="text-align: right">$1600</td>
<td style="text-align: right">$1600</td>
</tr>
<tr>
<td>99 000</td>
<td style="text-align: center">45</td>
<td style="text-align: right">$12</td>
<td style="text-align: right">$1600</td>
</tr>
<tr>
<td>98 100</td>
<td style="text-align: center">57</td>
<td style="text-align: right">$1</td>
<td style="text-align: right">$1600</td>
</tr>
</tbody></table>

<!-- <img src="/assets/images/400.gif"><br> -->

<!-- <img src="/assets/images/testimg1.jpeg"> -->

<p><br></p>

<hr>

<h2>Stop the Loss</h2>

<h3>Tight Stop Loss</h3>

<p>Det finns fördelar  och nackdelar med en tight stop.</p>

<h4>Tight Stop uttryckt i Procent</h4>

<p>Jag tar 5% som exempel på en tight stop i uttryckt i procent.</p>

<p>Om jag vill riska 5000 kr - säg att jag har ett total kapital på 500 000 kr - för at köpa AZN @ 550kr så skall jag köpa:
<pre>5000 / (550*0.05) = 181,82 ≈ 181 aktier</pre></p>

<p>Det betyder också att om priset på AZN går ner 5% till 522,50 kr så kommer jag att stoppas ur och har då gjort en förlust på 5 000 kr.</p>

<p><a href="https://www.tradingview.com/x/zxvm2VHr/"><img src="/assets/images/azn_tightstop_01.png" ></img></a></p>

<h4>Tight Stop uttryckt i Points</h4>

<blockquote>
<p><a href="http://www.investopedia.com/ask/answers/04/043004.asp#ixzz3yu4hVqso">För aktier gäller allmänt att</a>: For stocks, one point equals one dollar. So when you hear that a stock has lost or gained X number of &quot;points&quot;, this is the same as saying that the stock has lost or gained X number of dollars.</p>
</blockquote>

<p>En tight stopp loss uttryckt i points skulle kunna vara 2 points - alltså $2.</p>

<pre>Om jag vill riska $1000 med en $2 stopp så skall jag
alltså köpa $1000/2 = 500 aktier.
</pre>

<h4>Nackdelar med en tight stopp loss</h4>

<p>En tight stopp innebär att jag kommer att stoppas ur rätt ofta. Av den anledningen är det viktigt att vara försiktig när intradag voltilitet är hög.</p>

<p>En annan nackdel är att jag kommer att behöva köpa mer
aktier när jag har en tight stop och på så vis binda upp mer av mitt kapital.</p>

<pre>
En stopp loss på 5% innebär att jag behöver köpa  
1R/0.05 = 20R i aktier.

Med en 25% stopp loss behöver jag bara köpa  
1R/0.25 =  4R i aktier.

I fallet med Astra Zeneca aktierna skulle det innebära att
jag handlar
5000 / (550*0.25) = 36,36 ≈ 36 aktier
till en kostnad på 36*550 = 19 800 kr.

Jämför detta med 181 aktier
till en kostnad på 181*550 = 99 550 kr, eller 20%
av vårt totala kapital på 100 000 kr.
</pre>

<h4>Fördelar med en tight stopp loss</h4>

<p>Det är enkelare att få en hög R-Multipel när vi använder en tight stopp. Får vi en förlust så är även denna relativt liten vid en tight stopp loss.</p>

<blockquote>
<p><a href="http://www.investopedia.com/terms/s/slippage.asp#ixzz3yuIfAWgh">Slippage</a>: The difference between the expected price of a trade, and the price the trade actually executes at. Slippage often occurs during periods of higher volatility, when market orders are used, and also when large orders are executed when there may not be enough interest at the desired price level to maintain the expected price of trade.</p>
</blockquote>

<h3>Bred Stop Loss</h3>

<p>En bred stopp skulle kunna vara en 25% trailing stopp
eller till exempel en 100 kr stop på AZN.</p>

<h4>Fördelar och nackdelar med en bred stopp</h4>

<ul>
<li>  Jag riskerar inte att stoppas ut lika ofta.</li>
<li>  Jag behöver heller inte binda upp så mycket kapital
eftersom att jag kan köpa en mindre mängd aktier.</li>
<li>  Jag kan uppleva det som att kursen oftare rör sig i enlighet med min TA eftersom att jag inte stoppas ut på grund av intradagsvolatiliteten i aktien.</li>
</ul>

<p>Nackdelen är att jag får en mindre R-Multipel - kursen
måste rör sig oerhört mycket för att jag skall kunna få en hög R-Multipel.</p>

<hr>

<h3>Volatilitetsbaserad Positionsdimensionering</h3>

<p>Hur kan vi ta vara på fördelar från både en tight stop och en bred stop?
En möjlighet är att välja storleken på stop lossen utifrån aktiens volatilitet.</p>

<p>Om vi helt enkelt tar reda på de senaste dagarnas volatilitet i aktien, så kan
vi använda denna för vår positionsdimensionering.</p>

<p>Det kan dessutom vara smart att multiplicera denna volatilitet med en faktor så att vi håller oss utanför rangen och sänker risken för att stoppas ut.</p>

<p>Om TLSN de senaste 5 dagarna i genomsnitt haft en range på 10 kr, så kan jag
till exempel välja att sätta min stop loss 2 ggr detta värde under det pris jag väljer att ta en position.</p>

<pre>
Exempel

Säg att den genomsnitliga rangen de senaste tre dagarna
i FING är 20 kr.  

Istället för att som tidigare köpa 1000/2 = 75 aktier
så köper vi nu istället:
1 000 / 50 = 20 aktier  

Jag sätter stopp lossen på 20 kr * 2 = 40 kr
För ett aktuellt pris på 550 kr så blir det 550 - 40 = 510 kr.
</pre>

<h5>Här är ett liknande exempel med Telia Sonera (priset i Euro)</h5>

<p>I första grafen ser vi att priset ser ut att börja gå sidleds mellan 0.5 och
full retrace på fibben. Jag söker därför att korta aktien nästa gång den är på
väg upp för att testa resistance nivån (.5 fib nivån).</p>

<p><a href="https://www.tradingview.com/x/CRFbZojd/"><img src="/assets/images/tlsn_01.png" ></img></a></p>

<p>Aktien studsar som väntat mot resistance nivån (fib 0.5).
Molnet som omger priset representerar de fem senaste dagarnas genomsnittliga range, multiplicerat med den stop loss risk jag vill ha - i detta fall 2 ggr genomsnittlig rangen.</p>

<pre>
Exempel
Om priset på en aktie i varierat med 10 kr per dag </pre>

Som man kan se når inte priset ända ner till support, vilket påminner om vikten
av att ta profit på vägen mot target.

<a href="https://www.tradingview.com/x/7ACyqsAl/"><img src="/assets/images/tlsn_02.png" ></img></a>

#### Hur lönsam blir denna trade?

Genom att använda R-Multipel-konceptet kan vi enkelt generalisera diskussioner
kring hur profitabla våra trades är.

<pre>
Vad blir det för R-Multipel?

Köppris: €48.79  
Stopp loss vid: €50.85 (€2.06 eller 4.2% ovanför 0.5 fibben)  
1R är allstå: €2.06  
Target: €40.69  
R-Multipel: (48.79 - 40.69) / 2.06 ≈ 3,9R  
</pre>

<p>Det betyder alltså att denna trade ger ca 3.9 gånger satsat kapital, förutsat
att volymerna är tillräckligt stora för att jag skall få mina ordrar fyllda.</p>

<p>Volatilitetsbaserad positionsdimensionering känns spontant ganska användbart,
det finns helt klart många olika intressant strategier att koda fram och testa.</p>

<hr>

<h3>Procentrisk Positionsdimensionering</h3>

<p>En av de vanligaste Anti Martingale Strategierna.</p>

<h3>Optimal Risk</h3>

<h2>Högre R/R</h2>

	  ]]></description>
	</item>


</channel>
</rss>
